# 面向对象技术（Java）大作业二实验报告

## 0. 基本信息

### 0.1 小组成员信息与分工

|成员|学号|主要分工|权重|
|---|---|---|---|
|（待填写）|（待填写）|（待填写：如 客户端界面/服务端业务/数据库/导入导出/文档与测试 等）|（待填写）|
|（待填写）|（待填写）|（待填写）|（待填写）|
|（待填写）|（待填写）|（待填写）|（待填写）|

分组情况说明：小组按模块进行协作开发，客户端（JavaFX 交互与页面联动）、服务端（Socket 协议与业务路由）、数据库（表结构与事务一致性）、数据导入导出（Excel/CSV/PDF 报表）、文档与测试（实验报告与用例验证）等工作由不同成员负责，并在联调阶段共同完成端到端验证。

### 0.2 项目信息

- **项目名称**：飞马星球医院预约挂号微系统（HABMS）
- **实现模式**：C/S 架构（JavaFX 客户端 + Java Socket 服务端）
- **语言/环境**：Java 17，Maven 多模块（`client`、`server`）
- **数据存储**：MariaDB/MySQL（脚本：`server/src/main/resources/init_habms.sql`）
- **网络协议**：TCP 长连接，单行 JSON 请求/响应

---

## 1. 需求分析

### 1.1 业务场景与参与者

- **患者（Patient）**：注册/登录后查询科室与医生排班，完成预约与取消，维护个人信息。
- **医生（Doctor）**：查看候诊列表，按顺序叫号并完成就诊。
- **管理员（Admin）**：维护医生与排班数据，进行批量导入导出，并生成统计报表。

### 1.2 核心需求（文字说明）

- **功能性需求**
  - 患者端：注册、登录、科室/医生查询、预约/取消、个人信息修改。
  - 医生端：登录、查看候诊、叫号/完成。
  - 管理端：医生与排班维护、Excel/CSV 导入、预约记录导出、统计报表生成。

- **技术性需求**
  - C/S 架构：客户端仅与服务端通信，不直连数据库。
  - 网络：TCP 长连接，单行 JSON 请求/响应。
  - 并发：服务端多线程处理连接；预约等关键操作需保证一致性。
  - 数据库：MariaDB/MySQL，服务端通过 JDBC 统一访问。

---

## 2. 总体设计与架构分析

### 2.1 架构选型（模式二）

本项目采用要求中推荐的**模式二**：

- **客户端**：只与服务端通信，不直接访问数据库
- **服务端**：负责业务校验、并发控制、数据库访问
- **数据库**：仅对服务端可见

优点：

- 安全：客户端不暴露 DB 连接与账号
- 可扩展：所有业务规则集中在服务端
- 易于并发控制：预约扣减与状态变更可用事务统一处理

### 2.2 模块划分

- `client` 模块（JavaFX）
  - `controller/*`：登录、患者、医生、管理员界面逻辑
  - `net/NetworkClient`：TCP 长连接通信
  - `service/*`：对网络请求封装（例如认证、科室查询）
  - `model/*`：DTO/数据对象

- `server` 模块（Java Socket + JDBC）
  - `ServerMain`：入口，加载配置、初始化 DB、启动监听
  - `ServerRuntime`：`ServerSocket.accept()` + 线程池分发 `Service`
  - `Service`：单连接请求循环 + 路由分发 + 会话态
  - `HABMS.db`：数据库访问与核心事务（`HABMSDB`）

### 2.3 核心代码与架构落地（节选）

本节通过关键代码片段说明第 2 章中的架构职责划分如何落到实现层面。

#### 2.3.1 服务端监听 + 线程池分发（多线程）

服务端使用 `ServerSocket.accept()` 接受连接，并将每个连接交给线程池处理，实现“一个连接一个 `Service` 实例”的并发模型：

```java
// server/.../ServerRuntime.java
while (running.get()) {
    try {
        Socket socket = serverSocket.accept();
        executor.submit(new Service(socket, db, departments));
    } catch (IOException acceptError) {
        if (running.get()) {
            LOG.log(Level.WARNING, "Accept failed", acceptError);
        }
    }
}
```

对应关系：

- **网络服务端程序**：`ServerSocket` 监听端口并接受客户端连接。
- **多线程**：线程池并发处理多个连接，避免单连接阻塞影响整体吞吐。

#### 2.3.2 单连接请求循环 + 路由分发 + 会话态

`Service` 负责处理一个 TCP 长连接上的多次请求：读取一行 JSON，解析为 `Request`，按 `type` 分发到不同业务处理函数，并基于 `sessionAccount/sessionDoctor` 维护登录态。

```java
// server/.../Service.java
private Response handleLine(String line) {
    Request req = mapper.readValue(line, Request.class);
    if (req.type == null || req.type.isBlank()) {
        return err("type missing");
    }
    JsonNode data = req.data != null ? req.data : mapper.createObjectNode();
    return switch (req.type) {
        case "account_login" -> handleAccountLogin(data);
        case "department_list" -> handleDepartmentList();
        case "appointment_create" -> handleAppointmentCreate(data);
        // ... other routes
        default -> err("unknown type: " + req.type);
    };
}
```

对应关系：

- **协议层**：统一的 `type + data` 消息格式，使客户端/服务端解耦。
- **路由层**：`switch(type)` 将请求映射到业务函数，便于扩展与维护。
- **会话态**：在同一连接内保存登录状态，支持多次请求复用连接（长连接）。

#### 2.3.3 客户端长连接 + 单行 JSON 收发

客户端通过 `NetworkClient` 维护到服务端的 TCP 连接，并以“单行 JSON”方式发送请求、读取响应：

```java
// client/.../net/NetworkClient.java
public Response sendRequest(Request request) throws IOException {
    if (socket == null || socket.isClosed()) {
        connect();
    }

    String jsonReq = JsonUtil.toJson(request);
    out.println(jsonReq);

    String jsonResp = in.readLine();
    if (jsonResp == null) {
        throw new IOException("Server closed connection");
    }

    return JsonUtil.fromJson(jsonResp, Response.class);
}
```

对应关系：

- **C/S 分层**：客户端只负责界面与交互，不直接访问数据库。
- **长连接**：同一 Socket 上发送多次请求，避免频繁连接开销。
- **单行协议**：每条消息一行，便于服务端按行读取与边界判定。

---

## 3. 网络协议设计（TCP 单行 JSON）

### 3.1 消息格式

- 请求：`{"type":"...", "data":{...}}\n`
- 响应：`{"Statu":"ok|err", "data":... | "errInfo":"..."}\n`

接口清单参考：`server/NETWORK_API.md`。

### 3.2 会话设计

服务端 `Service` 为每个 Socket 连接维护会话态：

- `sessionAccount`：患者登录态
- `sessionDoctor`：医生/管理员登录态

通过路由层统一检查：

- 患者接口需 `sessionAccount != null`
- 医生接口需 `sessionDoctor != null`
- 管理接口需 `sessionDoctor.isAdmin() == true`

---

## 4. 数据库设计与初始化

### 4.1 表结构概览

脚本位置：`server/src/main/resources/init_habms.sql`

- `Account`：患者
- `Doctor`：医生（含 `Admin` 标记与科室）
- `Schedule`：排班（容量 `Capacity` 与剩余 `Res`）
- `Appointment`：预约（含状态 `Ok/Abandon/Done`）

### 4.2 主键与约束设计要点

- AID 10 位、DID 8 位、APID 12 位（由 `HABMS.db.IdGenerator` 生成）
- `Doctor` 增加唯一约束：`(Name, Department)`，避免同科室同名医生冲突
- `Schedule` 增加唯一约束：`(DID, STime, ETime)`，避免重复排班

### 4.3 数据初始化

- 初始化数据库与表：执行 `init_habms.sql`
- 默认管理员账号（科室“管理”）：
  - 用户名：`Admin`
  - 密码：`admin`

---

## 5. 关键业务逻辑实现分析

本章说明关键业务校验与并发一致性保证方式，并给出必要的关键 SQL/逻辑描述。

### 5.1 注册与有效性验证

- **年龄校验**：年满 10 岁才允许注册（客户端拦截）
- **字段有效性**：姓名/身份证/手机号等为必填与格式校验（客户端 + 数据库唯一约束）
- **密码安全**：客户端对密码进行 SHA-256 计算，服务端存储 Hex（避免明文传输/存储）

核心实现（节选）：

```java
// client/.../LoginController.java
private String hexSha256(String input) {
    try {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hash = digest.digest(input.getBytes(StandardCharsets.UTF_8));
        StringBuilder hexString = new StringBuilder();
        for (byte b : hash) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}

@FXML
private void handleRegister(ActionEvent event) {
    String ageText = regAgeField != null ? regAgeField.getText() : "";
    if (ageText == null || ageText.trim().isEmpty()) {
        setRegisterStatus(false, "请输入年龄");
        return;
    }
    int age;
    try {
        age = Integer.parseInt(ageText.trim());
    } catch (NumberFormatException ex) {
        setRegisterStatus(false, "请输入有效的数字年龄");
        return;
    }
    if (age < 10) {
        setRegisterStatus(false, "年龄需不小于10岁");
        return;
    }

    String passwordHex = hexSha256(regPasswordField != null ? regPasswordField.getText() : "");
    Task<Response> task = authService.registerAccount(name, pid, phone, passwordHex, sex);
}
```

说明：客户端在提交注册前完成年龄校验与密码散列；服务端只接收 `passwordHex`，避免明文密码在网络中传输。

```java
// server/.../Service.java
private Response handleAccountRegister(JsonNode data) throws Exception {
    String name = requiredText(data, "name");
    String passwordHex = requiredText(data, "passwordHex");
    String pid = requiredText(data, "pid");
    String phone = requiredText(data, "phone");
    Sex sex = parseSex(data.path("sex"));

    if (db.FindAccount(null, pid, null) != null) return err("PID already exists");
    if (db.FindAccount(null, null, phone) != null) return err("phone already exists");

    Account account = Account.create(name, passwordHex, pid, phone, sex);
    db.InsertAccount(account);
    sessionAccount = account;
    sessionDoctor = null;
    return ok(view(account));
}
```

说明：服务端对 PID/手机号做唯一性校验，创建账户并建立会话态。

关键位置：

- 客户端：`client/.../LoginController.handleRegister()`
- 服务端注册：`server/.../Service.handleAccountRegister()`
- 数据写入：`server/.../HABMSDB.InsertAccount()`

### 5.2 科室/医生查询

- 科室：服务端从 `department.json`（或 jar 内资源）加载
- 医生查询：支持按科室过滤、按姓名检索

核心实现（节选）：

```java
// server/.../DepartmentLoader.java
static List<String> load(Path path) {
    ObjectMapper mapper = new ObjectMapper();
    CollectionType type = mapper.getTypeFactory().constructCollectionType(List.class, String.class);

    try {
        if (Files.exists(path)) {
            List<String> list = mapper.readValue(path.toFile(), type);
            return list.stream().map(String::trim).filter(s -> !s.isEmpty()).toList();
        }
        try (InputStream is = ServerMain.class.getClassLoader().getResourceAsStream("department.json")) {
            if (is == null) {
                return Collections.emptyList();
            }
            List<String> list = mapper.readValue(is, type);
            return list.stream().map(String::trim).filter(s -> !s.isEmpty()).toList();
        }
    } catch (IOException e) {
        return Collections.emptyList();
    }
}
```

说明：支持从文件系统或 JAR 内资源两种方式加载科室列表，便于本地开发与部署运行。

```java
// server/.../Service.java
private Response handleDepartmentList() {
    return ok(new ArrayList<>(departments));
}

private Response handleDoctorQuery(JsonNode data) throws Exception {
    String department = textOrNull(data, "department");
    if (department != null) {
        if (!departments.isEmpty() && !departments.contains(department)) {
            return err("department not exists");
        }
        return ok(Arrays.stream(db.FindDoctorAccounts(department)).map(this::view).toList());
    }
    // ... did/name query
}
```

说明：科室查询直接返回服务端内存中的 `departments`；医生查询在按科室过滤时对科室合法性进行校验。

关键位置：

- 服务端：`Service.handleDepartmentList()`、`Service.handleDoctorQuery()`
- 客户端：患者主界面加载科室/医生列表（`PatientMainController`）

### 5.3 预约挂号：事务与并发控制（重点）

预约挂号是本系统的并发核心，目标：

- **不超卖**：号源 `Res` 不能被并发扣成负数
- **一致性**：扣减号源与插入预约必须“要么都成功，要么都失败”
- **唯一性约束（作业要求）**：同一患者同一时间段只能预约一个号源

实现策略（服务端事务）：

1. **原子扣减号源**（防超卖）

   - SQL：`UPDATE Schedule SET Res=Res-1 WHERE SID=? AND Res>0`
   - 若受影响行数不为 1，说明号源不足 -> 回滚

2. **同一时间段唯一预约校验**（满足作业要求）

   - 通过 `Appointment JOIN Schedule` 判断患者是否已有状态为 `Ok` 且时间段重叠的预约
   - 重叠判定：`NOT (existingEnd <= newStart OR existingStart >= newEnd)`

3. **插入预约记录**

   - 插入 `Appointment` 后提交事务

关键位置：

- 服务端路由：`server/.../Service.handleAppointmentCreate()`
- 数据库事务：`server/.../HABMSDB.TryAppointment()`

核心实现（节选）：

```java
// server/.../Service.java
private Response handleAppointmentCreate(JsonNode data) throws Exception {
    if (sessionAccount == null) return err("not logged in");
    int sid = requiredInt(data, "sid");

    Appointment appointment;
    try {
        appointment = db.TryAppointment(sessionAccount.getAid(), sid);
    } catch (java.sql.SQLException ex) {
        if (ex.getMessage() != null && ex.getMessage().contains("duplicate appointment in time slot")) {
            return err("already has appointment in this time slot");
        }
        throw ex;
    }
    if (appointment == null) return err("capacity is zero");
    return ok(view(appointment));
}
```

说明：服务端将“同时间段重复预约”与“号源不足”区分为两类错误响应，便于前端给出明确提示。

```java
// server/.../HABMSDB.java
public Appointment TryAppointment(String aid, int sid) throws SQLException {
    String updateSql = "UPDATE Schedule SET Res=Res-1 WHERE SID=? AND Res>0";
    String selectSchedule = "SELECT DID, STime, ETime FROM Schedule WHERE SID=?";
    String overlapSql = "SELECT 1 FROM Appointment a JOIN Schedule s ON a.SID=s.SID "
            + "WHERE a.AID=? AND a.Statu='Ok' AND NOT (s.ETime<=? OR s.STime>=?) LIMIT 1";
    String insertAppointment = "INSERT INTO Appointment(APID,AID,DID,SID,Statu) VALUES (?,?,?,?,?)";

    try (Connection conn = getConnection()) {
        boolean oldAutoCommit = conn.getAutoCommit();
        conn.setAutoCommit(false);

        try (PreparedStatement ps = conn.prepareStatement(updateSql)) {
            ps.setInt(1, sid);
            int updated = ps.executeUpdate();
            if (updated != 1) {
                conn.rollback();
                conn.setAutoCommit(oldAutoCommit);
                return null;
            }
        }

        String did;
        LocalDateTime sTime;
        LocalDateTime eTime;
        try (PreparedStatement ps = conn.prepareStatement(selectSchedule)) {
            ps.setInt(1, sid);
            try (ResultSet rs = ps.executeQuery()) {
                if (!rs.next()) {
                    conn.rollback();
                    conn.setAutoCommit(oldAutoCommit);
                    return null;
                }
                did = rs.getString("DID");
                sTime = rs.getTimestamp("STime").toLocalDateTime();
                eTime = rs.getTimestamp("ETime").toLocalDateTime();
            }
        }

        try (PreparedStatement ps = conn.prepareStatement(overlapSql)) {
            ps.setString(1, aid);
            ps.setTimestamp(2, Timestamp.valueOf(sTime));
            ps.setTimestamp(3, Timestamp.valueOf(eTime));
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    conn.rollback();
                    conn.setAutoCommit(oldAutoCommit);
                    throw new SQLException("duplicate appointment in time slot");
                }
            }
        }

        Appointment appointment = Appointment.create(aid, did, sid, AppointmentStatus.Ok, sTime, eTime);
        try (PreparedStatement ps = conn.prepareStatement(insertAppointment)) {
            ps.setString(1, appointment.getApid());
            ps.setString(2, appointment.getAid());
            ps.setString(3, appointment.getDid());
            ps.setInt(4, appointment.getSid());
            ps.setString(5, appointment.getStatus().name());
            ps.executeUpdate();
        }

        conn.commit();
        conn.setAutoCommit(oldAutoCommit);
        return appointment;
    }
}
```

说明：在同一事务内完成号源扣减、时间段重叠校验、插入预约三步，保证并发一致性与作业要求的唯一性约束。

### 5.4 取消预约：状态机与号源回补

取消预约的关键在于：

- 必须校验预约归属（只能取消自己的）
- 状态变化要与号源保持一致

实现策略：

- 事务内 `SELECT ... FOR UPDATE` 锁定预约行
- 若从 `Ok -> Abandon`，执行 `UPDATE Schedule SET Res=Res+1` 回补
- 更新预约状态并提交事务

关键位置：

- 服务端：`Service.handleAppointmentCancel()`
- 数据库：`HABMSDB.ChangeAppointmentStatu()`

核心实现（节选）：

```java
// server/.../Service.java
private Response handleAppointmentCancel(JsonNode data) throws Exception {
    if (sessionAccount == null) return err("not logged in");
    String apid = requiredText(data, "apid");
    Appointment ap = db.FindAppointment(apid);
    if (ap == null) return err("apid not exists");
    if (!sessionAccount.getAid().equals(ap.getAid())) return err("aid and apid not match");
    db.ChangeAppointmentStatu(apid, AppointmentStatus.Abandon);
    return ok(view(db.FindAppointment(apid)));
}
```

说明：取消预约先校验预约归属，避免越权取消。

```java
// server/.../HABMSDB.java
public void ChangeAppointmentStatu(String apid, AppointmentStatus statu) throws SQLException {
    String selectSql = "SELECT Statu, SID FROM Appointment WHERE APID=? FOR UPDATE";
    String updateAppointmentSql = "UPDATE Appointment SET Statu=? WHERE APID=?";
    String restoreScheduleResSql = "UPDATE Schedule SET Res=Res+1 WHERE SID=?";

    try (Connection conn = getConnection()) {
        boolean oldAutoCommit = conn.getAutoCommit();
        conn.setAutoCommit(false);

        AppointmentStatus oldStatus;
        int sid;
        try (PreparedStatement ps = conn.prepareStatement(selectSql)) {
            ps.setString(1, apid);
            try (ResultSet rs = ps.executeQuery()) {
                if (!rs.next()) {
                    conn.rollback();
                    conn.setAutoCommit(oldAutoCommit);
                    return;
                }
                oldStatus = AppointmentStatus.valueOf(rs.getString("Statu"));
                sid = rs.getInt("SID");
            }
        }

        if (oldStatus == AppointmentStatus.Ok && statu == AppointmentStatus.Abandon) {
            try (PreparedStatement ps = conn.prepareStatement(restoreScheduleResSql)) {
                ps.setInt(1, sid);
                ps.executeUpdate();
            }
        }

        try (PreparedStatement ps = conn.prepareStatement(updateAppointmentSql)) {
            ps.setString(1, statu.name());
            ps.setString(2, apid);
            ps.executeUpdate();
        }

        conn.commit();
        conn.setAutoCommit(oldAutoCommit);
    }
}
```

说明：通过事务与行级锁保证“状态更新”和“号源回补”同步发生，避免并发下资源数异常。

### 5.5 医生叫号：按序处理候诊并置为完成

- 医生端仅展示 `Ok`（候诊）预约
- “叫号下一位”按 `SerialNumber` 从小到大选择下一条
- 服务端将其状态置为 `Done`

关键位置：

- 服务端：`Service.handleDoctorCallNext()`
- 客户端：`DoctorMainController.handleCallNext()`

核心实现（节选）：

```java
// server/.../Service.java
private Response handleDoctorCallNext(JsonNode data) throws Exception {
    int sid = requiredInt(data, "sid");
    int currentSerial = optionalInt(data, "serialNumber", -1);
    Appointment[] appointments = db.FindAppointmentBelongSchedule(sid);
    Appointment next = Arrays.stream(appointments)
            .filter(a -> a.getDid().equals(sessionDoctor.getDid()))
            .filter(a -> a.getSerialNumber() > currentSerial)
            .filter(a -> a.getStatus() == AppointmentStatus.Ok)
            .min(Comparator.comparingInt(Appointment::getSerialNumber))
            .orElse(null);
    if (next == null) return err("no next appointment");
    db.ChangeAppointmentStatu(next.getApid(), AppointmentStatus.Done);
    return ok(view(db.FindAppointment(next.getApid())));
}
```

说明：服务端以 `SerialNumber` 单调递增挑选“下一位候诊（Ok）”并置为 `Done`，保证叫号顺序可追溯。

```java
// client/.../DoctorMainController.java
Map<String, Object> data = new HashMap<>();
data.put("sid", selectedSchedule.getSid());
data.put("serialNumber", currentSerialNumber);
Request req = new Request("doctor_call_next", data);
Response resp = NetworkClient.getInstance().sendRequest(req);
```

说明：客户端只提交排班与当前序号，业务顺序由服务端统一决定，避免前端并发/刷新导致的顺序错误。

### 5.6 管理端：导入 / 导出 / 月报生成

- **导入医生/排班**：支持 `csv/txt/xls/xlsx`，Excel 解析使用 Apache POI。
- **导出预约记录**：生成 `xls` 文件。
- **月度统计报告**：按月份聚合（科室预约量、医生工作量）生成 `pdf`。

关键位置：

- 客户端：`AdminMainController`
  - `handleImportDoctors()`、`handleImportSchedules()`
  - `handleExportAppointments()`
  - `handleGenerateReport()`

核心实现（节选）：

```java
// client/.../AdminMainController.java
private List<Map<String, Object>> parseDoctorFile(File file) throws IOException {
    String name = file.getName().toLowerCase(Locale.ROOT);
    if (name.endsWith(".csv") || name.endsWith(".txt")) return parseDoctorCsv(file);
    if (name.endsWith(".xls") || name.endsWith(".xlsx")) return parseDoctorExcel(file);
    throw new IOException("仅支持 csv/txt/xls/xlsx 文件");
}

@FXML
private void handleImportDoctors(ActionEvent event) {
    Task<Response> task = new Task<>() {
        @Override
        protected Response call() throws Exception {
            List<Map<String, Object>> doctors = parseDoctorFile(file);
            Map<String, Object> data = new HashMap<>();
            data.put("doctors", doctors);
            return NetworkClient.getInstance().sendRequest(new Request("admin_add_doctors", data));
        }
    };
    new Thread(task).start();
}
```

```java
// client/.../AdminMainController.java
private void doExportAppointments(List<Appointment> source) {
    try (Workbook workbook = new HSSFWorkbook(); FileOutputStream fos = new FileOutputStream(file)) {
        Sheet sheet = workbook.createSheet("Appointments");
        for (Appointment app : source) {
            Row row = sheet.createRow(rowIdx++);
            row.createCell(0).setCellValue(app.getApid());
            // ... other fields
        }
        workbook.write(fos);
    }
}

// client/.../AdminMainController.java
Map<String, Integer> deptCount = new HashMap<>();
Map<String, Integer> doctorCount = new HashMap<>();
for (Appointment app : monthApps) {
    deptCount.put(dept, deptCount.getOrDefault(dept, 0) + 1);
    doctorCount.put(doctorKey, doctorCount.getOrDefault(doctorKey, 0) + 1);
}

Document document = new Document();
PdfWriter.getInstance(document, fos);
document.open();
document.add(new Paragraph("预约月度报告 - " + targetMonth, zhTitleFont));

PdfPTable deptTable = new PdfPTable(2);
deptTable.addCell(new Paragraph("科室", zhBodyFont));
deptTable.addCell(new Paragraph("预约量", zhBodyFont));
deptCount.forEach((k, v) -> {
    deptTable.addCell(new Paragraph(k, zhBodyFont));
    deptTable.addCell(new Paragraph(String.valueOf(v), zhBodyFont));
});
document.add(deptTable);

PdfPTable doctorTable = new PdfPTable(2);
doctorTable.addCell(new Paragraph("医生", zhBodyFont));
doctorTable.addCell(new Paragraph("预约量", zhBodyFont));
doctorCount.forEach((k, v) -> {
    doctorTable.addCell(new Paragraph(k, zhBodyFont));
    doctorTable.addCell(new Paragraph(String.valueOf(v), zhBodyFont));
});
document.add(doctorTable);

document.close();
}
```

## 6. 操作说明（从 0 到可运行）

### 6.1 环境准备

- JDK：17
- Maven：3.8+
- MariaDB/MySQL：建议 MariaDB 10+

### 6.2 数据库初始化

1) 启动数据库服务
2) 执行脚本：`server/src/main/resources/init_habms.sql`

数据库初始化的执行截图见第 7 章。

### 6.3 启动服务端

- 服务端 jar：`server/target/habms-server-0.1.0-SNAPSHOT-fat.jar`
- 默认端口：`9000`

服务端启动与监听截图见第 7 章。

### 6.4 启动客户端并连接远程

- 客户端 jar：`client/target/habms-client-0.1.0-SNAPSHOT.jar`
- 通过环境变量指定服务端：`SERVER_HOST`、`SERVER_PORT`

---

## 7. 功能与实现截图

### 7.1 业务场景与参与者（截图）

- **患者（Patient）**

  - **入口与核心流程**：登录后查询医生/排班并完成预约。

    ![患者预约挂号](media/person_book_page.png)

    *图示：患者端按科室查看医生列表与排班信息，并可选择号源提交预约请求。*

    ![患者预约列表](media/person_book_list_page.png)

    *图示：在“我的预约”中查看预约号与状态，证明预约结果可追踪。*

- **医生（Doctor）**

  - **候诊与叫号**：按顺序处理候诊并完成。

    ![医生叫号页面](media/doctor_call_page.png)

    *图示：医生端候诊列表与“叫号下一位”入口，证明医生端能处理候诊。*

    ![叫号后状态变化](media/Appointment_call_change.png)

    *图示：在 MariaDB 中查询 `Appointment` 表，验证叫号/取消后预约状态更新（如 `Done/Abandon`）。*

- **管理员（Admin）**

  - **管理能力**：医生/排班管理、导入导出与报表。

    ![管理端主页](media/admin_page.png)

    *图示：管理端首页入口，包含医生管理/排班管理/报表等功能模块。*

    ![排班导入](media/schedule_import.png)

    *图示：管理员可批量导入排班（xls/xlsx/csv），用于快速初始化数据。*

    ![生成月报入口](media/export_pdf.png)

    *图示：管理员一键生成统计报表（PDF），证明具备导出与统计能力。*

### 7.2 评分点逐条对照（截图证据）

#### 7.2.1 项目基础分（功能）70 分

- **能够正常注册患者（10）**

  - **证据截图**：

    ![注册页0](media/sign_up0.png)

    *图示：注册表单包含姓名/身份证/手机号/年龄/性别等关键字段，用于证明“注册患者”功能。*

    ![注册页](media/sign_up.png)

    *图示：年龄输入为 9 时提示“年龄需不小于10岁”，证明客户端侧完成基础有效性校验。*

    ![注册成功](media/sign_up_ok.png)

    *图示：注册成功提示，证明服务端成功写入并返回 ok。*

  - **说明**：注册页面包含年龄输入；系统要求“年满 10 岁（age ≥ 10）”才允许提交。注册成功后可切换登录完成进入患者主页。

- **能够正确查询科室和医生（10）**

  - **证据截图**：

    ![患者端-科室/医生列表查询](media/person_book_page.png)

    *图示：患者端页面展示科室列表与医生列表（查询结果可见）。*

    ![客户端连接远程并成功返回科室列表](media/客户端连接远程.png)

    *图示：客户端连接远程服务端并返回科室列表（网络连通与接口返回）。*

  - **说明**：
    - 客户端从远程服务端拉取科室列表（`department_list`）并展示。
    - 患者端按科室过滤医生，展示医生信息并可继续查看排班。

- **能够正确预约和取消挂号（10）**

  - **证据截图**：

    ![预约挂号](media/person_book_page.png)

    *图示：从排班选择并提交预约请求。*

    ![我的预约列表](media/person_book_list_page.png)

    *图示：预约记录在列表中可见，证明预约创建成功并可查询。*

  - **说明**：
    - 预约创建后在“我的预约”可看到预约号、状态等信息。
    - 服务端对预约使用数据库事务扣减号源，并校验“同一患者同一时间段只能预约一个号源”（关键逻辑见第 5.3 节）。

- **能够修改信息（10）**

  - **证据截图**：

    ![个人信息页](media/person_info_page.png)

    *图示：个人信息页面（修改前）。*

    ![个人信息修改](media/person_info_change.png)

    *图示：修改姓名/电话等信息并提交。*

    ![修改后数据库核对](media/person_info_change_db.png)

    *图示：数据库记录同步更新，证明修改已落库。*

  - **说明**：修改个人信息后，数据库记录同步更新；身份证号/ID 等不可修改由服务端校验保证。

- **能够管理医生信息和排班（10）**

  - **证据截图**：

    ![管理端主页](media/admin_page.png)

    *图示：管理员入口与管理模块总览。*

    ![排班导入](media/schedule_import.png)

    *图示：排班管理与导入功能入口/执行界面。*

  - **说明**：管理员页面提供医生管理、排班管理与报表功能入口，可新增/导入并刷新排班数据。

- **通过导入 xls 批量添加医生和排班（10）**

  - **证据截图**：

    ![医生表样例](media/doctor_list_xlsx.png)

    *图示：医生导入 Excel 模板/示例文件。*

    ![医生导入成功](media/doctor_import_ok.png)

    *图示：导入成功提示，证明批量写入医生数据成功。*

    ![排班表样例](media/schedule_list_xlsx.png)

    *图示：排班导入 Excel 模板/示例文件。*

    ![排班导入](media/schedule_import.png)

    *图示：导入排班执行界面/结果。*

  - **说明**：管理端支持 `xls/xlsx/csv` 导入医生与排班；导入失败会提示原因（如下图）。

    ![医生导入失败示例](media/doctor_import_err.png)

    *图示：导入失败示例（缺字段/格式错误等），证明有错误提示与校验。*

- **导出预约记录和生成统计报告（10）**

  - **证据截图**：

    ![导出预约记录入口](media/export.png)

    *图示：导出预约记录入口。*

    ![导出结果-xls](media/xls.png)

    *图示：导出生成的 xls 文件结果。*

    ![生成月报入口](media/export_pdf.png)

    *图示：生成 PDF 月报入口。*

    ![生成结果-pdf](media/pdf.png)

    *图示：生成的 PDF 月报结果（可查看统计字段）。*

  - **说明**：
    - 预约记录可一键导出为 `xls`。
    - 月度统计报告生成 `pdf`，包含“科室预约量/医生工作量”等字段（聚合逻辑见第 5.6 节）。

#### 7.2.2 面向对象/网络/多线程/数据库 20 分

- **使用网络服务端程序（5） + 多线程（5）**

  - **证据截图**：

    见第 7.3 节“部署与联调”中的运行截图。

  - **说明**：服务端以 TCP Socket 监听端口（默认 9000），并为每个客户端连接分配线程池任务处理（详见第 2 章架构与第 3 章协议）。

- **使用数据库技术（5）**

  - **证据截图**：

    见第 7.3 节“部署与联调”中的运行截图。

  - **说明**：数据库使用 MariaDB，通过 JDBC 由服务端统一访问；预约与取消等关键操作使用事务保证一致性（详见第 5.3/5.4 节）。

### 7.3 部署与联调（运行截图）

![执行SQL](media/执行SQL.png)

*图示：数据库端执行初始化脚本成功（建表/授权/初始数据）。*

![服务器执行](media/服务器执行.png)

*图示：服务端启动并开始监听（端口 9000）。*

![客户端连接远程](media/客户端连接远程.png)

*图示：客户端连接远程公网 IP 并成功获取科室列表（端到端连通）。*

---

## 8. 构建与部署

1. 安装数据库（MariaDB）（任意位置，可以与服务器不同主机，可以通过网络访问即可）
2. 初始化数据库：运行`server\src\main\resources\init_habms.sql`脚本初始化数据库和 java 用户
3. 使用maven拉取依赖：项目根目录运行命令`./mvnw clean package`（需要网络连接）
    - 完成后：`client\target\habms-client-0.1.0-SNAPSHOT.jar`为客户端jar包
    - `server\target\habms-server-0.1.0-SNAPSHOT-fat.jar`为服务器jar包（通过scp将此包拷贝到服务器上）
4. 客户端命令行将`SERVER_HOST`和`SERVER_PORT`环境变量改为自己的服务器地址和端口。
5. 服务端如需要，修改`HABMS_PORT`、`HABMS_URL`、`HABMS_USER`、`HABMS_PASS`环境变量配置数据库连接。
6. 启动server：`java -jar habms-server-0.1.0-SNAPSHOT-fat.jar`
7. 启动client：`java -jar client\target\habms-client-0.1.0-SNAPSHOT.jar`

打包客户端为默认 Windows 平台，如需 mac/linux 切换 -Djavafx.platform=mac|linux

配置：使用`System.getenv`支持通过环境变量覆盖默认配置。可配置的环境变量有：

- `HABMS_PORT`：服务器监听端口（默认`9000`）
- `HABMS_URL`：数据库URL（默认`jdbc:mariadb://localhost:3306/HABMSDB`）
- `HABMS_USER`：数据库用户（默认`rjava`）
- `HABMS_PASS`：数据库用户密码（默认`rjava`）
- `HABMS_DEPARTMENTS`：部门信息配置文件（默认`department.json`）
- `SERVER_HOST`：（客户端）服务器主机位置（默认`localhost`）
- `SERVER_PORT`：（客户端）服务器端口（默认`9000`）

另外，如果要修改科室目录，请修改`server\src\main\resources\department.json`，默认只有内科、外科、儿科、骨科、皮肤科、管理。

本项目附带了一些测试用文件，主要是测试`xls`导入的，在`datas`目录下。

---

## 9. 实验收获

- **面向对象建模与分层**：通过 `Account/Doctor/Schedule/Appointment` 等领域对象进行抽象，将“界面交互、网络通信、业务逻辑、数据持久化”分层组织，降低模块耦合，便于迭代与维护。

- **TCP 长连接与协议设计**：采用“单行 JSON”请求/响应协议（`type + data`），统一入口与路由分发，使客户端与服务端在功能扩展时只需增加路由与处理函数，协议演进成本较低。

- **多线程服务端并发处理**：服务端以 `ServerSocket` 监听端口并将每个连接交由线程池处理，理解了并发场景下的连接生命周期管理与日志/异常处理的重要性。

- **数据库事务与一致性控制**：在预约创建与取消等关键路径中使用事务与行级锁，将“号源扣减/回补、时间段冲突校验、状态更新”等操作原子化，避免并发下的超卖或数据不一致问题。

- **GUI 交互与工程化实现**：基于 JavaFX 完成注册/查询/预约/叫号/导入导出等交互流程，并通过服务类封装网络请求、使用 Maven 管理依赖与打包，提升了可维护性与可交付性。

---

## 10. 项目文件结构

项目根目录 `HABMS/` 的主要文件结构如下（节选）：

```text
HABMS/
├─ pom.xml
├─ mvnw
├─ mvnw.cmd
├─ .mvn/
├─ .gitignore
├─ 实验报告.md
├─ media/
│  ├─ *.png
│  └─ ...
├─ datas/
│  ├─ doctor.xlsx
│  └─ schedule.xlsx
├─ client/
│  ├─ pom.xml
│  ├─ Client设计.md
│  └─ src/
│     └─ main/
│        ├─ java/HABMS/client/
│        │  ├─ App.java
│        │  ├─ Launcher.java
│        │  ├─ Session.java
│        │  ├─ controller/
│        │  │  ├─ LoginController.java
│        │  │  ├─ PatientMainController.java
│        │  │  ├─ DoctorMainController.java
│        │  │  └─ AdminMainController.java
│        │  ├─ model/
│        │  ├─ net/NetworkClient.java
│        │  ├─ service/
│        │  └─ util/JsonUtil.java
│        └─ resources/HABMS/client/
│           ├─ app.css
│           └─ view/
│              ├─ login.fxml
│              ├─ patient_main.fxml
│              ├─ doctor_main.fxml
│              └─ admin_main.fxml
└─ server/
   ├─ pom.xml
   ├─ NETWORK_API.md
   ├─ Server设计.md
   ├─ 数据对象与数据库接口.md
   ├─ department.json
   └─ src/
      ├─ main/
      │  ├─ java/HABMS/
      │  │  ├─ server/
      │  │  │  ├─ ServerMain.java
      │  │  │  ├─ ServerRuntime.java
      │  │  │  ├─ Service.java
      │  │  │  └─ DepartmentLoader.java
      │  │  └─ db/
      │  │     ├─ HABMSDB.java
      │  │     ├─ Account.java
      │  │     ├─ DoctorAccount.java
      │  │     ├─ Schedule.java
      │  │     ├─ Appointment.java
      │  │     ├─ AppointmentStatus.java
      │  │     ├─ IdGenerator.java
      │  │     └─ Sex.java
      │  └─ resources/
      │     ├─ init_habms.sql
      │     └─ department.json
      └─ test/
         └─ java/
            └─ HABMS/
               └─ db/
                  └─ ...
```

- **根目录**：`pom.xml` 为多模块 Maven 工程入口；`mvnw/mvnw.cmd` 为 Maven Wrapper；`实验报告.md` 为实验报告。
- **client/**：JavaFX 客户端模块，包含 UI（`*.fxml` + `app.css`）与控制器（`controller/`），并通过 `NetworkClient` 与服务端进行 TCP JSON 通信。
- **server/**：Socket 服务端模块；`HABMS/server` 包含服务端入口、监听与业务路由；`HABMS/db` 为数据库实体与 JDBC 访问封装；`init_habms.sql` 为数据库初始化脚本。
- **datas/**：导入功能的示例数据文件（医生/排班 Excel），用于演示管理端批量导入。
- **media/**：报告使用的功能截图与部署联调截图。
